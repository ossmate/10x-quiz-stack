# Code Generation Rules for Claude Code

This document defines rules and guidelines for all code generated by AI assistants to ensure it matches the project's linting and formatting standards from the start.

## Why These Rules Exist

Generated code should be production-ready and pass all linting/formatting checks without requiring manual fixes. This saves time and avoids extra commits for style fixes.

## Prettier Configuration

All generated code must follow these Prettier rules:

```json
{
  "semi": true,                    // Always use semicolons
  "singleQuote": false,            // Use double quotes
  "tabWidth": 2,                   // 2 spaces for indentation
  "printWidth": 120,               // Maximum line length: 120 characters
  "trailingComma": "es5"           // Trailing commas where valid in ES5
}
```

### Examples

**✅ Correct:**
```typescript
const quiz = {
  title: "My Quiz",
  description: "A sample quiz",
};

function getQuizzes(page: number, limit: number) {
  return fetch("/api/quizzes");
}
```

**❌ Incorrect:**
```typescript
const quiz = {
  title: 'My Quiz',              // Wrong: single quotes
  description: 'A sample quiz'   // Wrong: no trailing comma
}                                // Wrong: missing semicolon

function getQuizzes(page: number, limit: number)
{                                // Wrong: opening brace on new line
  return fetch('/api/quizzes')   // Wrong: single quotes, no semicolon
}
```

## ESLint Configuration

### Key Rules to Follow

1. **No Console Statements (Warning)**
   - Avoid `console.log`, `console.error` in production code
   - Exception: Error logging in catch blocks is acceptable
   - Use proper logging service or comment why console is needed

2. **TypeScript Strict Mode**
   - Always provide explicit types
   - Avoid `any` type - use proper types or `unknown`
   - Use interfaces/types from `src/types.ts` when available

3. **React Rules**
   - No need to import React in JSX files
   - Follow React Hooks rules (exhaustive-deps)
   - Use proper accessibility attributes (jsx-a11y)

4. **Unused Variables**
   - Never create unused variables
   - Remove or comment out unused imports/variables

### TypeScript Best Practices

**✅ Correct:**
```typescript
// Explicit types, no 'any'
interface QuizData {
  id: string;
  title: string;
}

function transformQuiz(quiz: Database["public"]["Tables"]["quizzes"]["Row"]): QuizDTO {
  const questions: QuestionWithOptionsDTO[] = quiz.questions
    .filter((q) => q.deleted_at === null)
    .map((question) => ({
      id: question.id,
      content: question.content,
    }));

  return { ...quiz, questions };
}
```

**❌ Incorrect:**
```typescript
// Using 'any' everywhere
function transformQuiz(quiz: any): any {
  const questions = quiz.questions
    .filter((q: any) => q.deleted_at === null)
    .map((question: any) => ({
      id: question.id,
      content: question.content,
    }));

  return { ...quiz, questions };
}
```

## File Structure & Imports

### Import Order
1. External dependencies (React, Astro, etc.)
2. Internal absolute imports (from `@/` or `~`)
3. Relative imports (from `./` or `../`)
4. Type imports (keep separate with `import type`)

**✅ Correct:**
```typescript
import type { APIRoute } from "astro";
import { createClient } from "@supabase/supabase-js";

import { quizService } from "../../../lib/services/quiz.service.ts";
import { uuidSchema } from "../../../lib/validation/uuid.schema.ts";

import type { Database } from "../../../db/database.types.ts";
```

### File Extensions
- Always include `.ts`, `.tsx`, `.js` extensions in imports
- Use `.ts` for TypeScript files
- Use `.tsx` for React components

## Code Style Guidelines

### 1. Function Declarations

**✅ Correct:**
```typescript
export const GET: APIRoute = async ({ url, locals }) => {
  // Implementation
};

async function getQuizzes(userId: string): Promise<QuizListResponse> {
  // Implementation
}
```

### 2. Error Handling

**✅ Correct:**
```typescript
try {
  const result = await operation();
} catch (error) {
  const errorMessage = error instanceof Error ? error.message : "Unknown error";
  console.error("Operation failed:", errorMessage); // Acceptable in catch blocks

  return new Response(
    JSON.stringify({
      error: "Error Type",
      message: "User-friendly message",
    }),
    { status: 500 }
  );
}
```

### 3. String Literals
- Use double quotes for strings
- Use template literals for string interpolation

**✅ Correct:**
```typescript
const message = "Hello World";
const greeting = `Hello ${name}`;
```

**❌ Incorrect:**
```typescript
const message = 'Hello World';         // Wrong: single quotes
const greeting = "Hello " + name;      // Wrong: string concatenation
```

### 4. Object and Array Formatting

**✅ Correct:**
```typescript
const quiz = {
  id: "123",
  title: "My Quiz",
  questions: [
    {
      id: "q1",
      content: "Question 1",
    },
    {
      id: "q2",
      content: "Question 2",
    },
  ],
};
```

### 5. Line Length
- Maximum 120 characters per line
- Break long lines appropriately

**✅ Correct:**
```typescript
const { data: quiz, error: quizError } = await supabase
  .from("quizzes")
  .select("*")
  .eq("id", quizId)
  .single();
```

## Documentation

### JSDoc Comments
Always add JSDoc comments for:
- Exported functions
- Service methods
- Complex logic

**✅ Correct:**
```typescript
/**
 * Retrieve paginated list of quizzes accessible to user
 *
 * @param supabase - Supabase client instance
 * @param userId - ID of the user requesting quizzes
 * @param query - Query parameters for pagination
 * @returns QuizListResponse with quizzes and pagination metadata
 * @throws Error if database operations fail
 */
async getQuizzes(
  supabase: SupabaseClientType,
  userId: string,
  query: QuizListQuery
): Promise<QuizListResponse> {
  // Implementation
}
```

## React-Specific Rules

### 1. Component Props
```typescript
interface ButtonProps {
  onClick: () => void;
  children: React.ReactNode;
  disabled?: boolean;
}

export function Button({ onClick, children, disabled = false }: ButtonProps) {
  return <button onClick={onClick} disabled={disabled}>{children}</button>;
}
```

### 2. Hooks
```typescript
// Correct: all dependencies listed
useEffect(() => {
  fetchQuizzes(page, limit);
}, [page, limit]);

// If you need to ignore exhaustive-deps, add comment
useEffect(() => {
  fetchQuizzes();
  // eslint-disable-next-line react-hooks/exhaustive-deps
}, []);
```

### 3. Accessibility
```tsx
// Always include labels and accessible attributes
<label htmlFor="quiz-title">
  Quiz Title
  <input id="quiz-title" type="text" aria-required="true" />
</label>
```

## Pre-Generation Checklist

Before generating any code, ensure:

- [ ] Using double quotes for strings
- [ ] Semicolons at end of statements
- [ ] 2-space indentation
- [ ] Line length under 120 characters
- [ ] No `any` types (use proper types)
- [ ] No unused variables or imports
- [ ] Console statements only in catch blocks with explanation
- [ ] Trailing commas in objects/arrays (ES5 style)
- [ ] File extensions included in imports
- [ ] JSDoc comments for public functions
- [ ] Proper TypeScript types throughout
- [ ] React accessibility attributes where needed

## Automatic Formatting

After generating code, the following command can fix formatting issues:

```bash
npm run lint:fix
```

However, the goal is to generate code that doesn't need this step!

## Project-Specific Patterns

### Error Response Format
```typescript
return new Response(
  JSON.stringify({
    error: "Error Type",
    message: "User-friendly error message",
    details: errorMessage, // Optional
  }),
  {
    status: 500,
    headers: {
      "Content-Type": "application/json",
    },
  }
);
```

### Service Layer Pattern
```typescript
// Services in src/lib/services/*.service.ts
export class QuizService {
  async getQuizzes(...): Promise<QuizListResponse> {
    // Implementation
  }
}

export const quizService = new QuizService();
```

### Validation Pattern
```typescript
// Schemas in src/lib/validation/*.schema.ts
import { z } from "zod";

export const quizListQuerySchema = z.object({
  page: z.coerce.number().int().min(1).default(1),
  limit: z.coerce.number().int().min(1).max(100).default(10),
});

export type QuizListQuery = z.infer<typeof quizListQuerySchema>;
```

## Summary

Following these rules ensures:
1. ✅ Code passes linting without changes
2. ✅ Code follows project conventions
3. ✅ No extra commits needed for style fixes
4. ✅ Consistent code quality across the project
5. ✅ Better developer experience

When in doubt, check existing code in the project for patterns and style!
